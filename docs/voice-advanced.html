<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="x-ua-compatible" content="ie=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimal-ui" />
		<link rel="stylesheet" href="build/conversational-form-docs.min.css">

		<script id="conversational-form-development" src="../dist/conversational-form.min.js"></script>
		<link rel="stylesheet" href="../dist/conversational-form.min.css">
		<!-- <script type="text/javascript" src="https://cf-4053.kxcdn.com/conversational-form/0.9.4/conversational-form.min.js" crossorigin></script> -->
	</head>
	<body>
		<main class="content">
			<menu id="small-screen-menu">
				<h2>Conversational Form examples</h2>

				<div class="switch-btn">
					<label class="switch">
						<input type="checkbox" onclick="window.conversationalFormExamples.toggleConversation(event)">
						<div class="slider round"></div>
					</label>
				</div>

				<div class="hamburger-btn" onclick="window.conversationalFormExamples.toggleMenuState(event)">
					<svg viewBox="0 0 29 14" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
						<g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="square">
							<g transform="translate(-325.000000, -87.000000)" stroke="#FFFFFF" stroke-width="2">
								<g transform="translate(325.000000, 87.000000)">
									<path d="M27.4802431,7 L1.23827993,7"></path>
									<path d="M27.4802431,1 L1.23827993,1"></path>
									<path d="M27.4802431,13 L1.23827993,13"></path>
								</g>
							</g>
						</g>
					</svg>
				</div>
			</menu>

			<div class="switch-btn" id="cf-toggle-btn" data-label="Enable Conversational Form" data-label-toggled="Disable Conversational Form">
				<label class="switch">
					<input type="checkbox" onclick="window.conversationalFormExamples.toggleConversation(event)">
					<div class="slider round"></div>
				</label>
			</div>

			<section id="info" role="info">
				<div class="close-btn" onclick="window.conversationalFormExamples.toggleMenuState()">
					<svg viewBox="0 0 22 22" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
						<g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="square">
							<g transform="translate(-328.000000, -83.000000)" stroke="#FFFFFF" stroke-width="2">
								<g id="close" transform="translate(329.000000, 84.000000)">
									<path d="M19.6371966,19.2779351 L1.08132646,0.722064927"></path>
									<path d="M19.4923318,0.722064927 L0.936461672,19.2779351"></path>
								</g>
							</g>
						</g>
					</svg>
				</div>

				<article>
					<h1 id="writer">
						Voice Control
					</h1>
					<h2>
						Fill out a firm using your voice. This example uses HTML5s SpeechSynthesisUtterance and SpeechRecognition APIs to have text 2 speech and speech 2 text.
					</h2>
				</article>
			</section>

			<section role="form">
				<div class="form-outer">

					<!-- Conversational Form will auto-run because of attribute "cf-form" -->
					<form id="form">
						<label for="123">Name</label>
						<input
							id="123"
							name="123"
							type="text"
							cf-questions="Hello, please tell me your name?"
						/>
						<label for="456">Favourite color</label>
						<fieldset id="456" cf-questions="Choose your favourite color, <span style='background: blue;'>blue</span>, <span style='background: red;'>red</span> or <span style='background: yellow;'>yellow</span>">
							<label for="1">Blue</label>
							<input type="radio" value="blue" id="1" />
							<label for="2">Red</label>
							<input type="radio" value="red" id="2" />
							<label for="3">Yellow</label>
							<input type="radio" value="yellow" id="3" />
						</fieldset>
					</form>
		
				</div>
			</section>

			<section id="cf-context" role="cf-context" cf-context>
				
			</section>
		</main>

		<script>
			var conversationalForm,
				recognition,
				msg;

			function toggleOff(){
				if(conversationalForm)
					conversationalForm.remove();
				conversationalForm = null;
				if(recognition){
					recognition.stop();
					recognition.onresult = null;
					recognition.onerror = null;
					recognition.onend = null;
					recognition = null;
				}

				if(msg){
					msg.onstart = null;
					msg.onend = null;
				}
			}

			function toggleOn(){
				toggleOff();

				var dispatcher = new cf.EventDispatcher(),
					synth = null,
					recognition,
					SpeechSynthesisUtterance = window.webkitSpeechSynthesisUtterance ||
						window.mozSpeechSynthesisUtterance ||
						window.msSpeechSynthesisUtterance ||
						window.oSpeechSynthesisUtterance ||
						window.SpeechSynthesisUtterance,
					SpeechRecognition = null;
					try{
						SpeechRecognition = SpeechRecognition || webkitSpeechRecognition;
					}catch(e){

					}
					
					if (!SpeechSynthesisUtterance) {
						console.log("Example support range: https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesisUtterance#Browser_compatibility")
						alert("Example requirement: SpeechSynthesisUtterance not supported, check your console");
						return;
					}

					// if (!SpeechRecognition) {
					// 	console.log("Example support range: https://developer.mozilla.org/en-US/docs/Web/API/SpeechRecognition#Browser_compatibility")
					// 	alert("Example requirement: SpeechRecognition Web API not supported, check your console for more data");
					// 	return;
					// }

				// here we use https://developer.mozilla.org/en-US/docs/Web/API/Web_Speech_API
				// you can use what ever API you want, ex.: Google Cloud Speech API -> https://cloud.google.com/speech/

				// here we create our input
				var microphoneInput = {
					// behaviors needs to follow the cf.IUserInput interface, they will be checked
					type: cf.UserInputTypes.VOICE,

					// template is optional, for cf.UserInputTypes.VOICE and cf.UserInputTypes.TEXT, there are default templates
					// through templates you can create total custom interfaces for the input like a WebVR interface :) PR!
					template: `<cf-input>
						<h1 class="custom-template">I am from a custom template ...</h1>
						<cf-input-button class="cf-input-button">
							<div class="cf-icon-audio"></div>
							<cf-icon-audio-eq></cf-icon-audio-eq>
						</cf-input-button>
					</cf-input>`,

					init: () => {
						// init is called one time, when the custom input is instantiated.

						// load voices \o/
						synth = window.speechSynthesis;
						if(!msg){
							msg = new SpeechSynthesisUtterance();
							window.speechSynthesis.onvoiceschanged = function(e) {
								var voices = synth.getVoices();
								msg.voice = voices[0]; // <-- Alex
								msg.lang = msg.voice.lang; // change language here
							};
							synth.getVoices();
						}

						// here we want to control the Voice input availability, so we don't end up with speech overlapping voice-input
						msg.onstart = function(event) {
							// on message end, so deactivate input
							console.log("voice: deactivate 1")
							conversationalForm.userInput.deactivate();
						}

						msg.onend = function(event) {
							// on message end, so reactivate input
							conversationalForm.userInput.reactivate();
						}

						// setup events to speak robot response
						dispatcher.addEventListener(cf.ChatListEvents.CHATLIST_UPDATED, function(event){
							if(event.detail.currentResponse.isRobotResponse){
								// https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesisUtterance
								// msg.text = event.detail.currentResponse.response
								msg.text = event.detail.currentResponse.strippedSesponse//<-- no html tags
								window.speechSynthesis.speak(msg);
							}
						}, false);

						// do other init stuff, like connect with external APIs ...
					},
					// set awaiting callback, as we will await the speak in this example
					awaitingCallback: true,
					cancelInput: () => {
						if(recognition){
							recognition.stop();
						}
					},
					input: (resolve, reject, mediaStream) => {
						console.log("voice: INPUT")
						// input is called when user is interacting with the CF input button (UserVoiceInput)

						// connect to Speech API (ex. Google Cloud Speech), Watson (https://github.com/watson-developer-cloud/speech-javascript-sdk) or use Web Speech API (like below), resolve with the text returned..
						// using Promise pattern -> https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise
							// if API fails use reject(result.toString())
							// if API succedes use resolve(result.toString())

						recognition = new SpeechRecognition(),
							finalTranscript = '';

						recognition.continuous = false; // react only on single input
						recognition.interimResults = false; // we don't care about interim, only final.
						
						// recognition.onstart = function() {}
						recognition.onresult = function(event) {
							// var interimTranscript = "";
							for (var i = event.resultIndex; i < event.results.length; ++i) {
								if (event.results[i].isFinal) {
									finalTranscript += event.results[i][0].transcript;
								}
							}
						}
						recognition.onerror = function(event) {
							reject("error: " + event.error);
						}
						recognition.onend = function() {
							resolve(finalTranscript);
						}

						recognition.lang = msg.voice.lang;
						recognition.start();
					}
				}

				var conversationalForm = window.cf.ConversationalForm.startTheConversation({
					formEl: document.getElementById("form"),
					context: document.getElementById("cf-context"),
					eventDispatcher: dispatcher,
					// add the custom input (microphone)
					userInput: microphoneInput,

					flowStepCallback: function(dto, success, error){
						success();
					},
					submitCallback: function(){
						// remove Conversational Form
						console.log("voice: Form submitted...", conversationalForm.getFormData(true));
						alert("You made it! Check console for data")
					}
				});
			};
		</script>

		<script src="build/conversational-form-examples.min.js" id="examples-script"></script>

		<style>
			.custom-template{
				font-size:12px;
				color:red;
			}

			main.content section[role=form] form > input{
				margin-bottom: 10px;
			}
			main.content section[role=form] form > label{
				display: block;
			}
			main.content section[role=form] form > fieldset > label, main.content section[role=form] form > fieldset > input{
				display: inline-block !important;
				width: auto;
			}
		</style>
	</body>
</html>
